Концептуальный алгоритм inContradiction(...) - version 3.0
-------------------------------------------

//Подразумевается, что предиката всегда на 2-ом месте
//За пределами этого алгоритма: Если (каждый элемент триплета существует в онтологии, то выполняем шаг (2) (ontContains()) //это будет вызов отдельной функций
//Информация об типе ошибки (из-за чего она была) должна быть более подробной(!), в этом и сила этого алгоритма.
//TODO:
//Добавить, что приходит класс (аксиома) в эту функцию (важно для реализации)!
//Требуется еще обсуждение алгоритма (см. комментарии в алгоритме)

1) Определяем (сохраняем) вид предикаты из присланного триплета
	1.1) Является ли предиката instanceOf // assertionAxiom //проверяется как обычный String
	1.2) Является ли предиката subClassOf //проверяется как обычный String
	1.3) Является ли предиката SubObjectPropertyOf | EquivalentObjectProperties |
    DisjointObjectProperties | InverseObjectProperties |
    ObjectPropertyDomain | ObjectPropertyRange |
    FunctionalObjectProperty | InverseFunctionalObjectProperty |
    ReflexiveObjectProperty | IrreflexiveObjectProperty |
    SymmetricObjectProperty | AsymmetricObjectProperty |
    TransitiveObjectProperty // сложный анализ с помощью owl api // или может быть найти метод...
	1.4) Является ли предиката Datatype
2) Определяем вид 1-ого элемента (тип/экземпляр)
3) Определяем вид 2-ого элемента (тип/экземпляр)
4) Если (тип-тип && (предиката != instanceOf || предиката != hasInstance)):
	4.1) Составить соответствующую аксиому с присланной (кастомной) предикатой
	4.2) Проверить соответствующую аксиому
	4.3) Если (true):
		4.3.1) return 0; // success
		4.3.2) return 1; // error
5) Если ((тип-экземпляр || экземпляр-тип) && (предиката == instanceOf || предиката == hasInstance)):
	5.1) Составить соответствующую аксиому
	5.2) Проверить соответствующую аксиому
	5.3) Если (true):
		5.3.1) return 0; // success
		5.3.2) return 1; // error
6) Если ((тип-экземпляр || экземпляр-тип) && (предиката != instanceOf || предиката != hasInstance)):
	// этот блок нуждается в дополнительном обсуждении (возвращать ошибку или действовать аналогично шагу (4))
	// Можно ли этот блок объединить с шагом (4)?
	.
	.
	.
	6.1) return 1; // error
7) Если (экземпляр-экземпляр && (предиката != instanceOf || предиката != hasInstance)):
	7.1) Составить соответствующую аксиому с присланной (кастомной) предикатой
	7.2) Проверить соответствующую аксиому
	7.3) Если (true):
		7.3.1) return 0; // success
		7.3.2) return 1; // error
//Начало блока "необычных" случаев:
8) Если ((тип-тип || экземпляр-экземпляр) && (предиката == instanceOf || предиката == hasInstance)):
	8.1) Если (предиката == instanceOf):
		//Подразумеваем, что на первом месте - instance, на третьем - type
		8.1.1) [аналогично шагу (5)]
		.
		.
		.
	8.2) Если (предиката == hasInstance):
		//Подразумеваем, что на первом месте - type, на третьем - instance
		8.2.1) [аналогично шагу (5)]
		.
		.
		.
		-----
		Конец.

