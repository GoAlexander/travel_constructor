Done features.
--------------

28.05.2018
-addInstance()
Теперь, если отправляется триплет, в котором указанного типа нет в кодифицированной онтологии, то онтология не изменяется.
И что важно: эта проверка теперь не на уровне OWL API, я теперь туда ontContains() вставил!


(до 12.11.2016)
-Инициализация агента и загрузка внутренней онтологии с удаленного сервера


-Возможность изменения самого файла онтологии на сервере (при добавлении фактов, интеграции знаний)


-Внутри агента все основные параметры передаются в формате IRI


-Разбор ACL-сообщения по типу: ACLMessage.INFORM (UserDefinedParameter: factTrue, factFalse), ACLMessage.QUERY_IF, ACLMessage.REQUEST
	[String processMessage(ACLMessage message)]
	Комментарий: 
		>Дополнительные типы сообщений задаются с помощью addUserDefinedParameter(String key, String value). Сейчас используются:
			Типы: 
				-type
					Значения "type":
						-factTrue -> для добавления новых фактов
						-factFalse -> для удаления фактов


-Добавление нового экземпляра класса в формате триплета, также может связывать указанные в триплете "экземпляр - класс". (для ACLMessage.INFORM (UserDefinedParameter: factTrue))
	[boolean addInstance(IRI subject, IRI object)]
	Комментарий: 
		>В случае, если в онтологии не существует такого класса, то вернет ошибку (проверка на уровне OWL API). 
		>Также получается, что благодаря этому методу  1 экземпляр класса может быть связан с разными классами, пример добавления:
			"Pizza(10.10.15) instanceOf Pizza" -> так как в онтологии еще не было такого экземпляра, то OWL API создаст такой экземпляр и свяжет его с классом Pizza
			"Pizza(10.10.15) instanceOf PizzaRecipe" -> так как такой экземпляр уже есть, просто свяжет Pizza(10.10.15) и PizzaRecipe
			"Pizza(10.10.15) instanceOf EatableProduct" -> аналогично, что в пункте выше
		

-Удаление экземпляра класса (для ACLMessage.INFORM (UserDefinedParameter: factFalse))
	[boolean deleteInstance(IRI subject, IRI object)]
	Комментарий:
		>Сразу разберем алгоритм удаления в случае, если один экземпляр класса связан с несколькими классами:
			1) Удаляется связь между присланными subject и object, т. е. экземпляр класса и класс
			2) Если экземпляр не связан больше ни с элементом онтологии, то он удаляется 


-Проверка существует ли экземпляр или класс в онтологии (для ACLMessage.QUERY_IF)
	[boolean ontContains (IRI object)]

-Проверка существует ли присланная аксиома (формата: экземпляр - класс) в онтологии (по факту проверка "связи") (для ACLMessage.QUERY_IF)
	[boolean ontContains (IRI subject, IRI object)]
	Алгоритм работы: (относительно ontContains (IRI object)) проверяет есть ли subject и object, а затем проверяет есть ли между ними связь.


(15.11.2016)
-Логирование всех входящих команд и отметкой об успехе их выполнения (файл AgentLog.log)
	>Логи ведутся в момента первого включения.
	>Логируются:
		>время по GMT
		>агент-отправитель сообщения
		>само сообщение
		>тип сообщения (INFORM/QUERY_IF/...)
		>обозначение успеха обработки сообщения (true/false)
	Пример: "15/11/2016 18:33:12 MSK-( agent-identifier :name SenderAgent@192.168.1.157:8888/JADE  :addresses (sequence http://X556UQ:7778/acc ))-"RussianPizza Pizza"QUERY_IF:false"

-Логирование всех изменений внутренней онтологии агента (файл {название_файла_кодифицированной_онтологии}.log)
	Пример: "INFORM(factFalse): RussianPizza instanceOf Pizza"

